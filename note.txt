12/08/07
	1.当数据库进行升级时，如果发现映射类中有并不存在的表，则创建该表。
	2.当数据库进行升级时，如果有创建新表，则重新检查并建立每张表的外键关联。
	3.修改之前的bug，建立外键关联时，先检查表中已有列，如果已经存在了外键列，则跳过不再添加。
12/08/08
	4.升级一张表时，检查出表中的每一个列的列表和类型，并组成一个TableModel对象返回。
	5.通过对比从数据库读取来的TableModel和传入的TableModel，来判断是否有新的字段加入。
12/08/09
	6.升级一张表时，当发现有新的字段加入时，生成一条增加列的语句。
	7.在Upgrader的analysis方法里面加入汇总所有要执行的SQL语句allExecutableSQLs。
	8.analysis方法中去执行allExecutableSQLs。
	9.OneToOneGenerator, ManyToOneGenerator等生成器中的rawQuery语句忘记进行大小写转化，现添加上。
12/08/10
	10.将从数据库中读取TableModel改成每次检查增加，删除，重命名列的时候都去重新查找一次，因为一旦执行以上操作，TableModel就会发生改变。
12/08/13
	11.为程序加入单元测试的框架。
	12.为创建表这一功能写测试用例，检查表是否存在。
	13.为创建表这一功能写测试用例，检查列是否存在。
	14.为创建表这一功能写测试用例，检查列的类型是否和数据库中的字段类型一致。
12/08/14
	15.对代码进行首次重构，主要修改了Generator类，将generate方法名改成createOrUpdateTables。同时把为表之间建立关联分成了两步，
	         第一步通过getRelations方法获取到所有存在关联关系的类，第二步根据获取到的RelationModel集合将关联关系映射到表中。将原来的一步
	         变为两步之后，升级表中很多需要用到获取关联关系的地方就能轻松获取到。
	16.为升级表写测试用例，检查新增的表是否已存在。
12/08/15
	17.为关联关系写测试用例，检查一对一，多对一，多对多关系建立的表和外键是否正确。
	18.对重构后的代码重新加注释。
12/08/16
	19.为Utility类写测试用例，并增加注释。
	20.在Utility类中增加getTableNameByForeignColumn方法。
12/08/21
	21.为Upgrader进行重构，之前的代码逻辑过于混乱。第一步先检查是否有新表应该加入数据库，完成之后还要建立表间关联。
	22.为Upgrader加入新表和检查表是否存在的方法加入注释。
	23.OdbParse不再返回OdbAttr对象，考虑以后改变解析方案
12/08/22
	24.重构Upgrader类中升级表时删除列相关的代码，并添加注释。
	25.升级表时加入添加列的功能，添加列要先于删除列，因为删除列时进行的数据迁移是从对象的table model中读取列的信息来进行迁移的，此时新添加
	        的列应该已在数据库当中。
12/08/25
	26.重构Upgrader类中升级表时添加列相关的代码，总体风格与删除列类似，并添加注释。
12/08/27
	27.重构Generator类，将创建或升级表时执行的createOrUpdate方法改名为createOrUpgradeTables
	28.将createOrUpgradeTables执行的代码分为两步，先一步先通过getTableModel获取到table model，然后将这个table model传入
	   createOrUpgradeTables方法去执行。
12/08/28
	29.为Utility增加了两个方法isTableExists和isColumnExists，并编写测试。
	30.编写Upgrader的测试，测试了增加列和删除列的功能。
	31.为Utility增加了containsIgnoreCases方法，在集合中使用简化代码，并编写测试。
12/08/31
	32.修复bug，如果实体类中含有一个id字段，在创建表的时候会出成有两个id字段的语句。在Creator中生成id字段后，需要把id从列名集合中删除。
	33.修改Upgrader中删除多余列时所用到的generateCreateNewTableSQL和generateDataMigrationSQL方法。这两个方法之前都是
	         使用class中的table model，这样会导致外键的列丢失。现在改成使用database中的table model再去除掉多余的列，保证没有列和数据会
	         丢失。
12/09/03
	34.将ManyToOneGenerator ManyToManyGenerator OneToOneGenerator这几个类的继承关系从Generator改为Creator，这样
	         更能体现出它们的作用是什么。
	35.为创建表加入新的测试用例，用于测试表之间的关联关系是否正确建立。
	36.在Utility中加入isIntermediateTable和getTableNameListByClassNameList两个方法，并编写测试。
12/09/04
	37.对代码进行较大幅度重构。将各种对数据库上进行操作时调用的changeCase方法全部取消掉，而改成在Generator的execute方法里进行统一的
	   changeCase。
	38.在Utility中添加findAllTableNames和findPragmaTableInfo两个方法，替换掉之前大量的数据库查询的重复方法，大幅度简化代码。
12/09/05
	39.之前Upgrader里的findColumnsToRemove方法存在漏洞。这里想要找到需要移除的列包括和类中字段不匹配的列，但是像主键和外键这样的列
	         也不会匹配类中的字段，而且这些列需要被保留下来。之前的算法在排除外键情况的时候存在漏洞，理想状况下如果类之间关系没有改变则不会出错，但是
	         当类之间的关系同时也进行了改变，则没有办法判断某一个列是否是外键。因此需要先对表进行关联升级，之后才能对表结构进行升级。
	40.代码架构进行了大幅度修改，但整体代码风格还是比较乱，没有什么实质性的进展。
12/09/06
	41.在之前的基础之上继续修改架构，现已基本符合良好架构风格。代码可读性增强，代码的复用性得到很大提高，继承的层性较为清晰明朗。Generator类
	         里的代码有些仍然不应该存放在里面，日后还需继续优化。Utility类里各类帮助代码过多，以后需要分别放在不同的帮助类里面。
	42.代码中使用的过多委托没有章法，需要去规整。
12/09/07
	43.在继承层次上使用委托的时候，原则一定要让方法的调用更简单。例如父类中如果有一个通用方法需要传递两个参数，而在子类中写了一个方法委托去调用父类
	         的方法，但是子类方法不需要再传参数或者少传参数了，那么这个委托就是成功的，因为简化了方法的调用方式。
	44.在升级表时同步表间关系，加入了删除中间表的功能。
	45.对整体架构再次修改，增加了创建表时代码的复用性。RelationsUpgrader中的findRelationsToRemove算法有bug，有待修正。
	46.修改架构后，升级表变成了先增加外键关键，再删除废弃的关键关联，这样很可能会引用bug。比如两张表的外键关联由多对一变成了一对一，如果先增加外键
	         则会发现此外键已存在，所以并不进行增加，但是随后再删除废弃外键，就造成了外键丢失了。由此证明25条的理论也是错误的。
12/09/10
	47.对之前25条的理论进行修正，应该先进行删除废弃的外键关联，然后再增加新的外键关联。同时应用到普通列中也是如此，先删除列，然后再增加新的列。
	48.删除中间表的代码移动到RelationsCreator中，因为只需执行一次就可以删除所有的中间表，不需要在RelationsUpgrader中循环执行。
	49.修复RelationsUpgraderk中findRelationsToRemove的bug，修复Upgrader中findColumnsToRemove的bug。
	         在findColumnsToRemove中，判断列是否需要移除的条件进行了优化。
12/09/11
	50.为之前的添加的功能以及修改的架构完善注释。
12/09/13
	51.重构RelationsCreator类，将去除外键关联的操作放在循环中一次执行完成。不再使用之前遍历每一个TableModel的时候去除外键关联的方式。
	52.对TableModel进行重构，将直接对columnsMap的操作全部替换掉，加入了getColumns，addColumn等有语义的方法来操作集合。
12/09/14
	53.修复Upgrader中db为空的bug，让程序在现有功能上可以正常运行。
12/09/17
	54.加入了Table_Schame作为一个存储所有创建过的表名的类，用于删除表时知道哪些表是自己创建的可以删除，哪些表是系统自带的，不能删除。
	56.修改OdbAttr的classNames，对集合操作进行封闭，并且延迟初始化，而且始终要为集合加入一个Table_Schema的值。
	57.添加新的列时，对主键列进行了过滤，由于表中已存在主键，如果再添加一个名为_id或者id的字段，则不更改数据库。
	58.对几个基本的条件语句进行重构，判断是否是id列和外键列的逻辑代码都提到了父类中。
12/09/18
	59.每新创建一张表，就会将表名插入到table_schema表中。表中不能存在重复记录。
12/09/19
	60.重构Generator接口，将创建和升级表的操作由单个对象操作，改为集合对象操作，并将接口名进行了修改。
	61.增加了删除在配置文件中不再存在的类对应的表的功能，同时将存在于table_schema中的相应的表名也一起删除掉。
	62.对Table_Schema增加了一个type字段，用来记录表是普通表还是中间表。
	63.每增加一个中间表，会向table_schema中增加一个字段，每删除一个中间表，会从table_schema中删除一个字段。
	64.修改Utility中isIntermediateTable的判断方法，现在要到table_schema去读取type字段来判断。
12/09/20
	65.把odb.xml从raw目录移动到了assets目录下面，就可以通过AssetManager来获取到文件，不像之前还需要传raw目录下文件的id了。
	66.Upgrader中判断列是否需要移除的逻辑混乱，且有一些空条件语句，现已将条件外移，可读性增加。
12/09/21
	67.修改删除列的代码的bug，之前的代码对于大小是区分的，导致表中的大小写和类中的不一样就没有办法把列删除掉。
	68.正式将软件名称改名为LitePal!!
	69.改了一些包名，完善了部分注释，准备上传到google code。
	
升级表时addColumn要进行重构  (已优化)
生成临时表要进行重构，防止出现表已存在的情况 (由于效率的问题，此情况不再考虑)
升级表时，外键的关联情况需要增加 (已完成)
尝试写一个不区分大小写的contain方法，来简化代码 (已提供此方法，之前的代码并没有都替换成使用此方法)
对于删除的类，要将表也一起删除掉 (已完成)
重命名字段名和重修改字段类型的情况需要考虑 (重命名字段不支持数据迁移功能，重命名的字段数据会丢失。)

工作流程：
	创建表：
		1. 创建所有表
		2. 为每一个表加入关联关系
	升级表：
		0. 删除废弃表，废弃外键在3步骤中无法删除，必须在此处一并删除。
		1. 建立新表 (一次完成)
		2. 删除不需要的外键关联 （循环执行完成  改为一次完成） 
		3. 删除不需要的中间表 (一次完成)
		4. 删除不需要的列 （循环执行完成  改为一次完成） 
		5. 增加新的列 （循环执行完成  改为一次完成）     
		6. 对于修改类型的字段，相当于删除这个列，再增加一个新列 (一次完成)
		7. 建立新的关键关联和中间表 (一次完成)
		
		
		
遗留问题：
级联存储时事务需要添加(已解决)
save时如果对象带有id，应该先检查表中是否已存在这个id，不存在则save，存在就应该update。(已换方案)
save时对于char这个情况需要做特殊处理，因为ContentValues里面不支持put char类型的数据。 (已解决)
自引用的问题需要考虑（例如好友关系的建立）， 继承和多态的表结构需要考虑


 向表中插入数据：
 1. 分析外键关联。
 2. 分析类中的字段，查询是否有外键字段，存入数据库。
 3. 存储关联的类。


方案修改：
不再使用级联存储策略，单存一个model的时候只去存储这个model的数据。
存储之前还是要检查关联关系。
由于在每个model的父类里都去加入和它有关联关系的model的实例，会让这个类变得非常庞大，所以现在改用只存储关联model的id。
DataSupport中改用associatedIdsWithFK和associatedIdsWithoutFK两个字段来保存关联的id。这两个字段都使用Map<String, List<Integer>>
作为类型，其中key保存关联model的类名（不需要加包名，因为数据库中的表也是没有包名的），而value则保存所有关联model的id值。
另外还有一个associatedIdsM2M字段，用来保存多对多关联的id值，字段类型同上。
	多对一关联：
		多端情况：通过检查associatedIdsWithoutFK的值，取出所有关联的一端的id作为外键值一起存入。为空就不存储外键值。
		一端情况：先存储好自己的值，然后检查associatedIdsWithFK的值，去把里面每一个id的行的外键更新为自己的id值。为空就不更新。
	一对一关联：
		有外键端情况：通过检查associatedIdsWithoutFK的值，取出所有关联的一端的id作为外键值一起存入。为空就不存储外键值。
		无外键端情况：先存储好自己的值，然后检查associatedIdsWithFK的值，去把里面每一个id的行的外键更新为自己的id值。为空就不更新。
	多对多关联：
		先存储自己的值，然后通过检查associatedIdsM2M的值，取出所有关联的id的值，联合自身的id，一起存入到中间表中。
		不用考虑多次存入中间表的情况，因为如果一个model已被存储，再次save时将会执行的是update，不会再向中间表插入数据。

一对一关联的方案修改：
	经过尝试，之前所使用过的一对一关联方案均不起作用，包括：
	1.在没有声明关联的一端存储外键(如果开发人员将单向关联改为双向，外键的位置将无法得到判断)
	2.在有声明关联的一端存储外键(问题同上)
	3.使用两张表名的字母表排序，外键放在字母表排序靠前的一端(单向关联时存储，有可能无法获取到关联的id)
	所以现在改用新方案来解决问题。哪一个类声明了一对一的关联关系，哪一个类的表中就有一个外键字段，如果是一对一双向关联，则两张表中都有一个外键字段。
	使用此方案也有一个潜在的问题，如果一开始只是单向关联，在表中拥有了一定数据后再将关联变为双向的，此时另一张表中虽然会加入新的字段，但这些字段的值
	都是空的。（此问题暂不解决）
	更新：之前所用的方案，在处理删除情况的时候存在问题，如果是声明关联关系的类含有外键，则在一对一单向关联的时候，删除被关联端的model，无法获取到
	它的任何关联信息，此时外键数据会一直被保留，无法删除。因此，现在还是改成使用在没有声明关联的一端存储外键，这样如果删除被关联的model，不需要获取
	关联关系外键数据就能删除。